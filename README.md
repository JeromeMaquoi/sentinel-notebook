# ICST 2025 replication package

This repository contains the replication package of the paper **Energy Codesumption, Source Code Level Analysis of Energy Consumption from Test Execution**, submitted at the 18th IEEE International Conference on Software Testing, Verification and Validation (ICST) 2025.

## Structure of the replication package

This replication package is structured as follows:

```
├── data
|   └── data.csv : CSV file containing the distribution of the analyzed call traces from spoon and spring-boot
├── plots : folder containing the plots generated by the scripts exported to pdf
└── scripts
    ├── tests : folder containing the unit tests of all the methods used in this repository to analyze the data
    ├── call_trace.py : contains the class CallTrace, representing one call trace
    ├── plotter.py : contains the Plotter class, responsible for the plotting of the data
    └── project_data.py : contains the ProjectData class, representing all the call traces of one project
```

## Getting started

1. Clone this repository
2. Go to the root of the repository
3. Create a new virtual environment: `python3 -m venv .venv`
4. Activate the environment: (for Linux users) `source .venv/bin/activate`
5. Open and execute the `scripts/analysis.ipynb` notebook in an IDE like VSCode

## Example of a call trace analysis

Here is an example of Java stack trace from the Spoon project, with each frame of the stacktrace associated to its line number. The association of this stacktrace with an energy consumption form a _call trace_.

```
spoon.[...].jdt.JDTBasedSpoonCompilerTest.testOrderCompilationUnits 35
spoon.[...].jdt.JDTBasedSpoonCompiler.buildUnits 418
spoon.[...].jdt.JDTBatchCompiler.getUnits 282
spoon.[...].jdt.TreeBuilderCompiler.buildUnits 82
```

Let's break down the stack trace above frame by frame. The first frame _spoon.[...].jdt.JDTBasedSpoonCompilerTest.testOrderCompilationUnits 35_ calls the method `testOrderCompilationUnits` at the line 35. For greater clarity, for each of the frame discussed in this example, only the lines we're interested in, or allowing us to understand the frame, will be shown.

```java
@Test
public void testOrderCompilationUnits() {
    // Rest of the code

    CompilationUnitDeclaration[] compilationUnitDeclarations = spoonCompiler.buildUnits(null, spoonCompiler.sources, spoonCompiler.getSourceClasspath(), ""); // Line 35

    // Rest of the code
}
```

The line 35 of the `testOrderCompilationUnits` method calls a method named `buildUnits`, which corresponds to the second frame: _spoon.[...].jdt.JDTBasedSpoonCompiler.buildUnits 418_. When we look at the source code of this method.

```java
/**
 * Build the CompilationUnit found in the source folder
 * @param jdtBuilder The instance of JDTBuilder to prepare the right JDT arguments
 * @param sourcesFolder The source folder
 * @param classpath The complete classpath
 * @param debugMessagePrefix Useful to help debugging
 * @return All compilationUnitDeclaration from JDT found in source folder
 */
protected CompilationUnitDeclaration[] buildUnits(JDTBuilder jdtBuilder, SpoonFolder sourcesFolder, String[] classpath, String debugMessagePrefix) {
    // Rest of the code

    JDTBatchCompiler batchCompiler = createBatchCompiler(new FileCompilerConfig(sourceFiles));

    // Rest of the code

    return batchCompiler.getUnits();
}
```
