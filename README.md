# ICST 2025 replication package

This repository contains the replication package of the paper **Energy Codesumption, Source Code Level Analysis of Energy Consumption from Test Execution**, submitted at the 18th IEEE International Conference on Software Testing, Verification and Validation (ICST) 2025.

## Structure of the replication package

This replication package is structured as follows:

```
├── data
|   └── data.csv : CSV file containing the distribution of the analyzed call traces from spoon and spring-boot
├── plots : folder containing the plots generated by the scripts exported to pdf
└── scripts
    ├── tests : folder containing the unit tests of all the methods used in this repository to analyze the data
    ├── call_trace.py : contains the class CallTrace, representing one call trace
    ├── plotter.py : contains the Plotter class, responsible for the plotting of the data
    └── project_data.py : contains the ProjectData class, representing all the call traces of one project
```

## Getting started

1. Clone this repository
2. Install the requirements from `scripts/requirements.txt` in a virtual environment
3. Open and execute the `scripts/analysis.ipynb` notebook in an IDE

## Example of a call trace analysis

Here is an example of Java stacktrace from the Spoon project, with each frame of the stacktrace associated to its line number. The association of this stacktrace with an energy consumption form a _call trace_.

```
spoon.[...].jdt.JDTBasedSpoonCompilerTest.testOrderCompilationUnits 35
spoon.[...].jdt.JDTBasedSpoonCompiler.buildUnits 418
spoon.[...].jdt.JDTBatchCompiler.getUnits 282
spoon.[...].jdt.TreeBuilderCompiler.buildUnits 82
```

Upon examining the second line of the call trace, _spoon.[...].jdt.JDTBasedSpoonCompiler.buildUnits 418_, we identify that the instruction of interest is the method named _buildUnits_. To better understand the context of this method, let's review the source code of this method.

```java
/**
 * Build the CompilationUnit found in the source folder
 * @param jdtBuilder The instance of JDTBuilder to prepare the right JDT arguments
 * @param sourcesFolder The source folder
 * @param classpath The complete classpath
 * @param debugMessagePrefix Useful to help debugging
 * @return All compilationUnitDeclaration from JDT found in source folder
 */
protected CompilationUnitDeclaration[] buildUnits(JDTBuilder jdtBuilder, SpoonFolder sourcesFolder, String[] classpath, String debugMessagePrefix) {
    List<SpoonFile> sourceFiles = Collections.unmodifiableList(sourcesFolder.getAllJavaFiles());
    if (sourceFiles.isEmpty()) {
        return EMPTY_RESULT;
    }

    JDTBatchCompiler batchCompiler = createBatchCompiler(new FileCompilerConfig(sourceFiles));

    String[] args;
    if (jdtBuilder == null) {
        ClasspathOptions classpathOptions = new ClasspathOptions().encoding(this.getEnvironment().getEncoding().displayName()).classpath(classpath);
        ComplianceOptions complianceOptions = new ComplianceOptions().compliance(javaCompliance);
        if (factory.getEnvironment().isPreviewFeaturesEnabled()) {
            complianceOptions.enablePreview();
        }
        AdvancedOptions advancedOptions = new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc();
        SourceOptions sourceOptions = new SourceOptions().sources(sourceFiles);
        args = new JDTBuilderImpl()
                .classpathOptions(classpathOptions)
                .complianceOptions(complianceOptions)
                .advancedOptions(advancedOptions)
                .sources(sourceOptions) // no sources, handled by the JDTBatchCompiler
                .build();
    } else {
        args = jdtBuilder.build();
    }

    getFactory().getEnvironment().debugMessage(debugMessagePrefix + "build args: " + Arrays.toString(args));
    batchCompiler.configure(args);

    return batchCompiler.getUnits();
}
```
